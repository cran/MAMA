%\VignetteDepends{MAMA, affy, GeneMeta, metaArray, tspair, xtable, metaMA, OrderedList, gtools, gplots, multtest, RankProd, annaffy} 
% \VignetteIndexEntry{An R Package for Meta-Analysis of Microarray}
% \VignetteKeywords{Microarray identify genes}
% \VignettePackage{MAMA}

\documentclass[a4paper]{article}

\title{MAMA: a 9 in 1 R package for Meta-Analysis of MicroArray}
\author{Ivana Ihnatova}

\begin{document}

\maketitle
\tableofcontents
\newpage
\part{Introduction}
%It is well-known that analysis of microarray is statistically difficult and results differ even in repeated experiments.  \par

%By combining data sets from different origins together, the test gets increased power, which leads to more identified genes \cite{Hong}.


%There are three main objectives in analysis of microarray: class comparison (finding of differentially expressed genes), class prediction (prognostic prediction) and class discovery (clustering or unsupervised analyses). 
This paper provides a user guide to R-package MAMA. The package implements nine different methods that have been proposed in meta-analysis of microarray and are designed to identify differentially expressed genes.\par


In here, we will demonstrate the features of the package with an example of meta-analysis in cancer microarray data, the comparison of expression profiles in MSI (microsatelite instable) and MSS (microsatelite stable) colon cancer. We gathered three microarray data from public databases. The data are stored in object {\ttfamily DataColonHalf}\par
The guide starts with package and sample data loading. 
<<lib>>=
rm(list=ls(all=TRUE))
options(width=60)
library(MAMA)
load(url("http://math.muni.cz/~xihnatov/DataColonHalf.RData"))
ls()
#source("C:\\Users\\user\\Desktop\\Diplomovka CD\\meta-analyza.R")
@
The original data sets have been preprocessed and subsampled in order to reduce the computational complexity. All data sets have been normalized and are in $log_2$-scale. The corresponding sample sizes tor the three datasets ({\ttfamily denmark} \cite{ausaden}, {\ttfamily australia} \cite{ausaden} and {\ttfamily japan} \cite{japan}) are 77 (39 MSI and 38 MSS), 36 (5 MSI and 31 MSS) and 41 (16 MSI and 25 MSS), respectively. In all expression profiles we have selected the same set of 500 genes for analysis.\par 
 Each of the datasets is stored as an ExpressionSet object - a specific container for microarray data and experimental metadata. The detailed information about this object can be found at \cite{Biobase}. Gene expression data matrix can be obtained by function {\ttfamily exprs()} and function {\ttfamily pData()} return a data frame with samples description (class labels). \par
A different method is used in each of parts below and parts are written to be independed from each other, so you can directly move to method that are of your interest. Meta-analysis usually consist of three steps: Data preparation (and its transformation if necessary), Detection of differentially expressed genes and Extraction and visualization of results. 
 
\part{Methods that combine p-values}
%\addcontentsline{toc}{part}{Methods that combine p-values}
\section*{Introduction}
%\addcontentsline{toc}{section}{Introduction}
In this part we will focus on methods that combine p-values \cite{Marot}, \cite{Rhodes}. These methods are inspired by Fisher's S-statistic published in 1925 \cite{Fisher25}. We usually obtain two measurements of significance of change in gene expression: value of test-statistic and p-value. These methods combine the p-values from study-specific analysis and combine them into one p-value in sense of sum of logs. Methods differ in test statistic that is used to calculate the study-specific p-value. 
\section*{Usage}
%\addcontentsline{toc}{section}{Usage}
\subsection*{Data preparation}
When using this implementation we have to merge all gene expression data matrices (\emph{exprs()}) and class labels vectors (\emph{pData()[,]}) to two lists. 
<<datap2>>=
esets<-list(exprs(denmark),exprs(australia),exprs(japan))
classes<-list(pData(denmark)[,1],pData(australia)[,1], pData(japan)[,2])
@
\subsection*{Detecting differentially expressed genes}
Functions \verb!pvalcombination! and \verb!pvalcombination.paired! provide meta-analysis based on combination of p-values. The former is designed for unpaired data and the latter for paired design of microarray experiments. Because, our data sets are unpaired, we will use \verb!pvalcombination!. The function requires: a list of gene expression data matrices ({\ttfamily esets}), a list of vectors of class labels ({\ttfamily classes}), type of test statistics ({\ttfamily moderated}) and threshold for significance ({\ttfamily BHth}). It returns list of indices of selected genes. Three possible values for argument {\ttfamily moderated} are available: {\ttfamily "t"} for common t-test, {\ttfamily "limma"} for moderated t-test used in limma package \cite{limma} and {\ttfamily "SMVar"} for moderated t-test defined in SMVar package \cite{SMVar}. 
<<DEGp>>=
pvalt<-pvalcombination(esets, classes, moderated = "t" , BHth = 0.01)
@
Several characteristics which have been defined in meta-analysis of microarray (especially for methods which combine p-values or effect sizes). This characteristics are outprinted by the function. {\ttfamily DE} denotes number of significant genes in meta-analysis. {\ttfamily IDD} represents Integration Driven Discoveries, it means genes which are significant in meta-analysis but not in any of the individual studies alone. Other way round, if a gene is significant only in individual data sets but not in meta-analysis, it is called Integration Driven Revision and {\ttfamily Loss} is a number of such genes. {\ttfamily IDR} and {\ttfamily IRR} are percentages of Integration Driven Discoveries and Integration Driven Revisions in identified differentially expressed genes ({\ttfamily DE}).  
%pvallimma<-pvalcombination(esets, classes, moderated = "limma" , BHth = 0.01)
%pvalSMVar<-pvalcombination(esets, classes, moderated = "SMVar" , BHth = 0.01)
@
\subsection*{Results}
<<resp>>=
summary(pvalt)
@
This object is a list with six slots. \emph{Study1} to \emph{Study3} are numeric vectors with indices of differentially expressed genes in data sets 1 to 3. \emph{AllIndStudies} is a vector of indices of differentially expressed genes in at least one data set. Differentially expressed genes found by meta-analysis have their indices stored in \emph{Meta}. And finally, a slot called \emph{TestStatistic} is a vector with test statistics in meta-analysis.  

%\section*{Discussion}
%\addcontentsline{toc}{section}{Discussion}

\part{Methods that combine effect sizes}
%\addcontentsline{toc}{part}{Methods that combine effect size}
\section*{Introduction}
%In the situation where $k$ microarray data sets are available and we want to estimate the mean difference in expression, for each gene, between two classes (e.g MSI and MSS colon cancer).\par
Methods that combine effect size use hierarchical model:
\[ y_i=\theta_i+\epsilon_i, \epsilon_i \sim N(0,\sigma_i^2)\]
\[ \theta_i=\mu+\delta_i, \delta_i \sim N(0,\tau_i^2),\]
where $\mu$ is true difference in mean expression between two classes, $y_i$ denotes the measure effect for study $i$, with $i=1,..,k$, $\tau^2$ represents the between study variability, $\sigma_i^2$ denotes the within study variability. The analysis is different depending on whether a fixed-effect model (FEM) or a random-effect model (REM) is deemed appropriate. Under a FEM, $\tau=0$ is assumed, otherwise a REM need to be fit. The estimates of the overall effect $\mu$ are different depending on which model is used. \par
Two papers dealing with effect size combination as method for meta analysis of microarray have been published \cite{Marot} and \cite{Choi2003}. They differ in effect size definition and implementation.\par Method presented in \cite{Marot} offers three variants of effect sizes (classical and moderated T-test) and uses explicitly random-effect model. It is implemented as two functions {\ttfamily EScombination} for unpaired data and {\ttfamily EScombination.paired} for paired data.  
\par On the other hand, in \cite{Choi2003} the effect size is defined as Hedge's and Olkin's $g$ and both random-effect and fixed-effect are available. Package \emph{GeneMeta} \cite{GeneMeta} implements this method. 
\section*{Algorithm}
\begin{enumerate}
\item Data recoding.
\item Effect size calculation in each data set.
\item Decision between random-effect model (REM) and fixed-effect model (FEM).
\item Model application.
\end{enumerate}
%\addcontentsline{toc}{section}{Introduction}
\section*{Usage}
Because there are two different ways of implementation for using combination of effect size method on microarray data sets, we will discuss them separately.
%\addcontentsline{toc}{section}{Usage}
\subsection*{Implementation from metaMA package}
\paragraph{Data preparation}
This method requires two lists, one containing the data matrices (\emph{exprs()}) and the other one the corresponding vectors of group labels (\emph{pData()[,]}).
<<>>=
esets<-list(exprs(denmark),exprs(australia),exprs(japan))
classes<-list(pData(denmark)[,1],pData(australia)[,1], pData(japan)[,2])
@
\paragraph{Detecting differentially expressed genes}
As we have unpaired data, we are going to use function {\ttfamily EScombination}. This function has four arguments: a list of gene expression data matrices ({\ttfamily esets}), a list of class labels vectors ({\ttfamily classes}), effect size definition ({\ttfamily moderated})  and a threshold for false discovery rate (FDR) ({\ttfamily BHth}). Three possible values for {\ttfamily moderated} are available: {\ttfamily "t"} for common t-test, {\ttfamily "limma"} for moderated t-test used in limma package \cite{limma} and {\ttfamily "SMVar"} for moderated t-test defined in SMVar package \cite{SMVar}. 
<<ESmetaMA>>=
ESt<-EScombination(esets, classes, moderated = "t" , BHth = 0.01)
@
Function {\ttfamily EScombination} prints several measures defined in meta-analysis of microarray. {\ttfamily DE} denotes number of significant genes in meta-analysis. {\ttfamily IDD} represents Integration Driven Discoveries, it means genes which are significant in meta-analysis but not in any of the individual studies alone. Other way round, if a gene is significant only in individual data sets but not in meta-analysis, it is called Integration Driven Revision and {\ttfamily Loss} is a number of such genes. {\ttfamily IDR} and {\ttfamily IRR} are percentages of Integration Driven Discoveries and Integration Driven Revisions in identified differentially expressed genes ({\ttfamily DE}). 
<<>>=
summary(ESt)
@
This object is a list with six slots. \emph{Study1} to \emph{Study3} are indices of differentially expressed genes in data sets 1 to 3. \emph{AllIndStudies} is a vector of indices of differentially expressed genes in at least one data set. Differentially expressed genes found by meta-analysis have their indices stored in \emph{Meta}. And finally, a slot called \emph{TestStatistic} is a vector with test statistics ("combined effect size") in meta-analysis. 

\subsection*{Implemenetation from GeneMeta package}
\paragraph{Data preparation}
Before calculating effect sizes we have to create vectors with class labels in form of $1$'s and $0$'s. $1$ is supposed to be for diseased samples and $0$ for normal samples. In data sets used as example in this document $1$ refers to MSI samples and $0$ to MSS.  
<<>>=
ph1<-pData(denmark)[,1]
levels(ph1) <- c(1, 0)
pData(denmark)[,1]
ph1
@ and similary for other data sets 
<<>>=
ph2<-pData(australia)[,1]
levels(ph2) <- c(1, 0)
ph3<-pData(japan)[,2]
levels(ph3) <- c(1, 0)

@
{\ttfamily ph1}, {\ttfamily ph2} and {\ttfamily ph3} are numeric vectors containing class labels for data sets {\ttfamily denmark}, {\ttfamily australia} and {\ttfamily japan}.  These vectors are needed as arguments for functions which provide effect size and its variability estimates. 

\paragraph{Detecting differentially expressed genes}
Functions {\ttfamily getdF}, {\ttfamily dstar} and {\ttfamily sigmad} estimate effect size and its variability for a individual data set, therefore we have to use them three-times. For {\ttfamily denmark} data set  
<<ESGeneMeta>>=
d.den <- getdF(denmark, ph1)
d.adj.den <- dstar(d.den, length(ph1))
var.d.adj.den <- sigmad(d.adj.den, sum(ph1 == 0), sum(ph1 == 1))
head(d.adj.den)
head(var.d.adj.den)
@ 
and for other two data sets 
<<>>=
d.aus <- getdF(australia, ph2)
d.adj.aus <- dstar(d.aus, length(ph2))
var.d.adj.aus <- sigmad(d.adj.aus, sum(ph2 == 0), sum(ph2 == 1))
d.jap <- getdF(japan, ph3)
d.adj.jap <- dstar(d.jap, length(ph3))
var.d.adj.jap <- sigmad(d.adj.jap, sum(ph3 == 0), sum(ph3 == 1))
@
Function {\ttfamily getdF} has two arguments: the data set (a ExpressionSet object or a matrix) and class labels (a factor or numeric vector with $1$ and $0$) and computes estimates of standardized mean difference, found in Hedge and Olkin's \cite{Hedges}. Function {\ttfamily dstar} corrects the estimates for sample size bias, therefore its second argument is sample size of the data set. Function {\ttfamily sigmad} calculates the estimate of variance of unbiased effect size. For calculation, the user has to provide effect size estimates and sample size of each class. \par
Now, we are going to use Chochran's $Q$ statistic \cite{Cochran} to test between-study variability, so we can decide whether we should be considering random-effect (REM) or fixed-effect model(FEM) for the data. \par
Function {\ttfamily f.Q} provides a straightforward calculation of Cochran's $Q$ statistic. If the null hypothesis that the between-study variance is equal to zero (data are well modeled by a fixed effects design) then the estimated Q values will have approximately a chi-squared distribution with degrees of freedom equal to the number of studies minus one. We are going to look at mean and histogram of $Q$ statistics. Later we will compare quantiles of $Q$ to quantiles of chi-square distribution.  

\begin{center}
<<fig=true, width=3, height=3>>=
mymns <- cbind(d.adj.den, d.adj.aus,d.adj.jap)
myvars <- cbind(var.d.adj.den, var.d.adj.aus,var.d.adj.jap)
my.Q <- f.Q(mymns, myvars)
mean(my.Q)
hist(my.Q, breaks = 50, col = "red")
@
\end{center}
\begin{center}
<<fig=true, width=3, height=3>>=
num.studies <- 3
plotQvsChi(my.Q, num.studies)
@ 
\end{center}
According to Q-Q plot the hypothesis seems to be valid and fixed-effect model (FEM) should be used. However, we are going to use random-effect model (REM) too, so we can see if there is any difference in estimates of combined effect size.\par  
The computation is simpler for FEM than for REM. Functions {\ttfamily mu.tau2} and {\ttfamily var.tau2} estimate combined effect size ({\ttfamily mu.tau2}) and variance ({\ttfamily var.tau2}). Each effect size is a weighted average of the effects for the individual data sets divided by its standard error. The weights are the reciprocal of the estimated variances.  

\begin{center}
<<fig=true, width=5, height=5>>=
#FEM
muFEM = mu.tau2(mymns, myvars)
sdFEM = var.tau2(myvars)
ZFEM = muFEM/sqrt(sdFEM)
qqnorm(ZFEM, pch = "*")
qqline(ZFEM, col = "red")
@
\end{center}

Plotting the quantiles of the effects we can see that the presumption of approximate Normality seems to be appropriate.\par
In REM we have to account between-study variability ($\tau^2$). Function {\ttfamily tau2.DL} provides DerSimonian's and Laird's \cite{DerSimonian} estimates of $\tau^2$ from Cochran's $Q$. It has two addional arguments: number of studies ({\ttfamily num.studies}) and weights ({\ttfamily my.weights=1/myvars}). We add between-study variability to estimated variance ({\ttfamily myvars}) and calculate the combined effect size like in FEM.
<<>>=
#REM
num.studies <- 3
my.tau2.DL <- tau2.DL(my.Q, num.studies, my.weights=1/myvars)
myvarsDL <- myvars + my.tau2.DL
muREM <- mu.tau2(mymns, myvarsDL)
varREM <- var.tau2(myvarsDL)
ZREM <- muREM/sqrt(varREM)
@
{\ttfamily muFEM} or {\ttfamily muREM} are numeric vectors with estimated combined (overall) effect size for a gene in FEM or REM. The estimated standard error of overall effect size for each gene is stored in numeric vectors: {\ttfamily varFEM} or {\ttfamily varREM}. We will test significance of overall effect size by Z-score ({\ttfamily ZFEM} or {\ttfamily ZREM}) defined as mean divided by standard error.\par
We can easily compare FEM estimates and REM estimates
\begin{center}
<<fig=true, width=5, height=5>>=
plot(muFEM, muREM, pch = "*")
abline(0, 1, col = "red")
@
\end{center} 
We do not see much difference here. Actually, for most of the genes the $\tau^2$ is estimated as zero. 
\begin{center}
<<fig=true, width=5, height=5>>=
hist.tau<-hist(my.tau2.DL, col = "red", breaks = 100, main = "Histogram of tau")
@
\end{center}
\paragraph{Results}
The procedure described in details above is also implemented in function {\ttfamily zScores}. The arguments of this function are a list of expression sets ({\ttfamily esets}) and a list of classes ({\ttfamily classes}). Argument {\ttfamily useREM} chooses between REM and FEM. 
<<>>=
esets <- list(denmark, australia, japan)
classes <- list(ph1, ph2, ph3)
theScores <- zScores(esets, classes, useREM = FALSE)
round(theScores[1:2, ],3)
@
We get a matrix ({\ttfamily theScores}) with the following columns:
\begin{itemize}
\item \emph{Effect\_Ex\_ } are the unbiased estimates of the effect (\emph{d.adj. })
\item \emph{EffectVar\_Ex\_ } are the estimated variances of the unbiased effects (\emph{var.d.adj. })
\item \emph{zSco\_Ex\_} are the unbiased estimates of the effects divided by their standard deviation 
\item \emph{Qvals} are the Q statistics (\emph{my.Q}) and df is the number of combined experiments minus one
\item \emph{MUvals} and \emph{MUsds} are equal to \emph{muFEM} and \emph{sdFEM} (the overall mean effect size and its standard deviation) 
\item \emph{zSco} are the z scores (\emph{ZFEM})
\item \emph{Qpvalues} is for each gene the probability that a chi-square distribution with \emph{df} degree of freedom has a higher value than its $Q$ statistic
\item \emph{Chisq} is the probability that a chi-square distribution with 1 degree of freedom has a higher value than \emph{zSco2}
\end{itemize}
Function {\ttfamily zScoresFDR} implements SAM \cite{SAM} type analysis to estimate the false discovery rate (FDR). 
<<>>=
ScoresFDR <- zScoreFDR(esets, classes, useREM = FALSE, nperm = 50, CombineExp = 1:3)
names(ScoresFDR) 
round(ScoresFDR$pos[1:2, ],3)
@ It is a list with three slots: {\ttfamily pos},{\ttfamily neg} and {\ttfamily two.sided}. The first slot stores the results of the calculation, if the FDR is computed for the positive Z-scores, the second for the negative Z-scores and the last one for the two sided situation. Each slots contains a matrix with similar structure as obtained by {\ttfamily zScores} with additional FDR for each data set and combination.\par  
Function {\ttfamily plotES} provides several visualizations of the results. Specifying {\ttfamily which=1} will plot so called \emph{IDRplot}. This plot shows the fraction of the genes that have a higher effect size than the threshold for the combined Z-score , but not for any of the data set specific Z-scores. Genes with combined Z-score $>0$ and $<0$ are plotted separately. Selection {\ttfamily which=2} will plot the number of genes and the corresponding FDR for the two sided situation. If the user is more interested in the number of genes that are below a given threshold for the FDR, he decides for {\ttfamily which=3}. It shows for each study (indicated by different colors) and various thresholds for the FDR (x axis) the number of genes that are below this threshold in the given study but above in all other studies are shown (y axis). If numeric vector is used that all figure specified in the vectors are plot. \par
Argument {\ttfamily legend.names} is a character vector with names of the date set used in legends and {\ttfamily colors} is a vector of colors to be used for plotting.
<<fig=true, width=8, height=5>>=
plotES(theScores, ScoresFDR, num.studies=3, legend.names=c("Combined set", "Denmark", "Australia", "Japan"), colors=c("red","blue","green","yellow"), which=1:3)
@

\part{Similarity of Ordered Gene Lists (SOGL)}
%\addcontentsline{toc}{part}{Similarity of Ordered Gene Lists (SOGL)}
\section*{Introduction}
%\addcontentsline{toc}{section}{Introduction}
Similarity of Ordered Gene Lists is another method for meta-analysis of microarray. It is call as "comparison of comparisons" by its authors \cite{Yang2006}. \par
Briefly, it assigns a similarity score to a comparison of two ranked (ordered) gene lists. The score is based on the number of overlapping genes in the top ranks. It computes the size of overlap for each rank. The final score is a weighted sum of these values, with more weight put on the top ranks. \par
\section*{Algorithm}
\begin{enumerate}
\item Required data sets - two data sets with same set of genes (or genes which can be mapped to each other) are required. 
\item Ranking of genes - The genes are then ranked based on gene-wise test on difference of class mean. There is only one assumption about test result: a large positive test score corresponds to up-regulation and a large negative value to down-regulation. 
\item Computing the overlap - for each rank (from 1 to number of genes) we count the number of genes that appear in both ordered lists up to that position. It is denoted as $O_n(G_A,G_B)$, where $G_A$ and $G_B$ refer to ordered gene lists.
\item Preliminary similarity score - First we compute a total overlap $A_n$ at position $n$ given as $O_n(G_A,G_B)+O_n(f(G_A),f(G_B))$, where $f()$ means flipped list (down-regulated genes on top). Later we add weights ($w_\alpha=e^{-\alpha.n}$)to it and we sum it up to preliminary score. Parameter $\alpha$ is needed to tune the weights: a smaller $\alpha$ puts more weight on genes
Further down the list. Implementation can choose an appropriate $\alpha$ itself.
\item Final similarity score - it takes two possibilities into account. The possibilities are: the class labels of the two data sets match or do not match.
\end{enumerate}
The algorithm above is valid for meta-analysis in which expression data are also available. However, we can analyze only two ordered gene list without expression data. It has two peculiarities: we can not use same approach for calculating the significance of overlap and we can not be sure if genes are ranked from the most up-regulated to the most down-regulated. Please see \cite{SOGL} for more details.  
\section*{Usage}
%\addcontentsline{toc}{section}{Usage}
\subsection*{Data preparation}
We will use only first two datasets ({\ttfamily denmark} and {\ttfamily australia}) and they need to be processed by function {\ttfamily dataSOGL}, so they can be merged into one "ExpressionSet" object with function {\ttfamily prepareData}. Function {\ttfamily dataSOGL} requires a ExpressionSet object ({\ttfamily data}), a column number for \emph{pData} to be used as class labels ({\ttfamily group}), a name for class labels ({\ttfamily groupname}) and microarray platform for \emph{annotation} ({\ttfamily annotation}). Function {\ttfamily prepareData} has three aguments: {\ttfamily eset1}, {\ttfamily eset2} and {\ttfamily mapping}. {\ttfamily eset1} and {\ttfamily eset2} are lists consisting of: a data set as a ExpressionSet object ({\ttfamily data}), name of the data set ({\ttfamily name}), name of the class labels ({\ttfamily var}), numeric vector of class labels used in data set ({\ttfamily out}) and a indicator whether paired data are present ({\ttfamily paired}). {\ttfamily mapping} is a two column data frame with probe IDs of {\ttfamily eset1} and {\ttfamily eset2}. The $k$th row of {\ttfamily mapping} provides the label of the $k$th gene in each single study. If all studies were done on the same chip, no mapping is needed. 
<<SOGLdata>>=
denmarkSOGL<-dataSOGL(data=denmark, group=1, groupname="satelite", annotation="hgu133plus2")
australiaSOGL<-dataSOGL(data=australia,group=1, groupname="satelite",annotation="hgu133plus2")
A <- prepareData(eset1 = list(data = denmarkSOGL, name = "colon_cancer1", var = "groupname", out = c(1, 2), paired = FALSE), eset2 = list(data = australiaSOGL,  name = "colon_cancer2", var = "groupname", out = c(1, 2), paired = FALSE), mapping=NULL)
@
\subsection*{Detecting differentially expressed genes}
Function {\ttfamily OrderedList} aims for the comparison of comparisons: given two combined expression studies the function produces a gene ranking for each study and quantifies the overlap by computing the weighted similarity scores. The final list of overlapping genes consists of those probes that contribute a certain percentage to the overall similarity score. We can choose three different statistics for gene ranking: t-test with equal variances, log ratio (log fold change) or Z-score (chosen explicitly, t-test with regularized variances). We apply function \verb!OrderedList! with default values to our combined data set. 
<<SOGLvyp>>=
x.z <- OrderedList(A, empirical = TRUE)
x.z
@
%x.fc <- OrderedList(A,test="fc" ,empirical = TRUE)
%x.fc
%x.t <- OrderedList(A,test="t", empirical = TRUE)
%x.t

\subsection*{Results}
The result is an object of class OrderedList for which print and plot function exist. Output from print function can be seen above and plot function is used below. The sorted list of overlapping genes is stored in \verb!$intersect!. 
<<>>=
x.z$intersect[1:12]
@
Calling {\ttfamily OrderedList} with the {\ttfamily empirical} option set to {\ttfamily true}, causes OrderedList to compute empirical bounds for expected overlaps. By default, this is switched off and underestimated bounds deduced from a hypergeometric distribution are used.
\begin{center}
<<fig=true, width=5, height=5>>=
plot(x.z,"pauc")
@ 
\end{center}
This is a plot of pAUC scores based on $\alpha$ selection. The separability between the two distributions of observed and random similarity score is measured by pAUC score. $\alpha$ is chosen where the pAUC score is maximal. It is marked by a vertical line.
\begin{center}
<<fig=true, width=5, height=5>>=
plot(x.z,"scores")
@ 
\end{center}
The red curve correspondence to kernel density estimate of simulated observed scores and the black curve to kernel density of simulated random scores. The actually observed similarity score is denoted by the vertical red line. The bottom rugs mark the simulated values. 
\begin{center}
<<fig=true, width=5, height=5>>=
plot(x.z,"overlap")
@ 
\end{center}
This plot displays the numbers of overlapping genes in the two gene lists. It is drawn as step function over the respective ranks. Top ranks correspond to up-regulated and bottom ranks to down-regulated genes. The expected overlap and  confidence intervals are shown too. They are derived empirically form the subsampling or deduced from a hypergeometric distribution, it depends on parameter {\ttfamily empirical}.
\section*{Notes} We can also compare directly two ordered gene lis via functions: {\ttfamily CompareLists} and {\ttfamily getOverlap}. Please see \cite{SOGL} for details. 
%\section*{Discussion}
%\addcontentsline{toc}{section}{Discussion}

\part{RankProduct}
%\addcontentsline{toc}{part}{RankProduct}
\section*{Introduction}
%\addcontentsline{toc}{section}{Introduction}
RankProduct is a non-parametric statistic that detects up-regulated and down-regulated genes under one condition against another condition. In our sample data set we look for difference in expression between MSI and MSS colon cancer. \par
It focuses on genes which are consistently highly ranked in a number of lists, for example genes that are regularly found among top up-regulated genes in many microarray studies. It assumes that under the null hypothesis that the order of all items is random then the probability of finding a certain item among the top $r$ of $n$ items in a list is $p=r/n$. Rank product is defined by multiplying these probabilities $RP=\prod_{i}\frac{r_i}{n_i}$, where $r_i$ is the rank of the item in the $i$-th list and $n_i$ is the total number of the items on $i$-th list. The smaller the $RP$ value the smaller the probability that the observation of the item at the top of the lists is due to chance. It is equivalent to calculating the geometric mean rank. A list of up- or down-regulated genes are selected based on the estimated percentage of false positive prediction (pfp), it is known as false discovery rate (FDR), too.
\section*{Algorithm}
Algorithm of the method has five steps:
\begin{enumerate}
\item Fold-change ratio is calculated in each data set.
\item Ranks are assigned (1 for the highest value) according to fold-change ratio. $r_{gi}$ is rank of gene $g$ in comparison $i$, where $i$ is from $1$ to $K$, where $K$ is sum of products of number of slides in groups.
\item RankProduct for a gene ($RP_g$) is calculated as $\prod_{i}r_{gi}^{1/K}$
\item $l$ permutations of expression values at each microarray slide is performed and all previous steps repeated. We obtain $RP_g^{(l)}$
\item Step 4 is repeated $L$ times to estimate the distribution of $RP_g^{(l)}$. This distribution is used to calculate p-value and pfp for each gene.
\end{enumerate}
\section*{Usage}
\subsection*{Data preparation}
In order to run a rank product meta-analysis, users need to call function {\ttfamily RPadvance}. They both require three arguments: {\ttfamily data}, {\ttfamily cl} and {\ttfamily origin}. The first required argument, {\ttfamily data}, is the matrix (or data frame) containing the gene expression data that should be analyzed. Each of its rows corresponds to a gene, and each column corresponds to a sample. Second and third argument, {\ttfamily cl} and {\ttfamily origin}, are vectors of length {\ttfamily ncol(data)} containing the class labels of the samples or the origin labels of the samples. Function {\ttfamily mergedata} returns a list with three slots corresponding to arguments described above. {\ttfamily class.col} argument is a numeric vector indicating which columns of \emph{pData} should be used as class labels. First number refers to first data set etc. 
<<rankdata>>=
rankdata<-mergedata(denmark, australia, japan, class.col=c(1,1,2))
rankdata$cl
rankdata$origin
@
In {\ttfamily cl} all $1$'s refer to MSI samples and all $2$'s to MSS samples. Similarly in {\ttfamily origin}, $1$ belongs to samples from first data set ({\ttfamily denmark}), $2$ from second data set ({\ttfamily australia}) and $3$ from {\ttfamily japan} study. You can choose different numbers for labels, but same numbers are always treated like same samples from same class or with same origin.
\subsection*{Detecting differentially expressed genes}
In this section, we show how the rank product method can be applied to detect differentially expressed gene in our data sets in sence of meta-analysis. It means we will get two separate lists (up- and down-regulated genes separately) not two such lists for each data set. For each gene, one pfp (percentage of false prediction) is computed and used to select significant genes.
We can run meta-analysis by
<<rankDEG>>=
RP.out<-RPadvance(rankdata$dat,rankdata$cl,rankdata$origin,num.perm=50,logged=TRUE,na.rm=FALSE,gene.names=rownames(exprs(denmark)), plot=FALSE)
@
The data are log-transformed, therefore we set {\ttfamily logged=TRUE}. The number of permutations is default set to 100, you can change it to higher number, if you wish more precise estimates of the pfp. The argument {\ttfamily plot=FALSE} will prevent the graphical display of the estimated pfp vs. number of identified genes. We will use function {\ttfamily plotRP} for a such display.
\subsection*{Results}
\begin{center}
<<fig=true, width=5,height=5>>=
plotRP(RP.out, cutoff=0.01)
@
\end{center}
The function {\ttfamily plotRP} graphicaly displays the estimated pfp vs. number of identified genes using the output from {\ttfamily RPadvance}. If cutoff (the maximum accepted pfp) is specified, identified genes are marked in red.
<<>>=
RankRes<-topGene(RP.out, cutoff=0.01)
head(round(RankRes$Table1,3))
head(round(RankRes$Table2,3))
@
The function \verb!topGene! is used to output a table of the identified genes from the output object from function \verb!RPadvance!. Table contains genes according to other arguments. It is obligatory to specify either the \verb!cutoff! (the desired significance of the identification) or \verb!num.gene! (the number of top genes identified), otherwise a error message will be printed and the function will be stopped. If cutoff is selected, user needs to choose between \verb!pfp! (percentage of false prediction) or \verb!pval! (p-value). \verb!pfp! is the default setting, which is selected when no selection is made.\par
Two tables are output, listing identified up- (Table1: class 1 < class 2) and down- (Table2: class1 > class 2) regulated genes. There are 5 columns in the table 
\begin{enumerate}
\item \emph{gene.index} is the gene index in the original data set
\item \emph{RP/Rsum} is the computed rank product for each gene
\item \emph{FC:(class1/class2)} is the computed fold change of the average expression levels under two conditions, which would be converted to the original scale using input logbase (default value is 2) if {\ttfamily logged=TRUE} is specified
\item \emph{pfp} is the estimated pfp value for each gene in the list if that gene serves as the cutoff point
\item \emph{P.value} is the associated P-values for each gene
\end{enumerate}

\section*{Notes}
%\addcontentsline{toc}{section}{Discussion}
By combining data sets from different origins together, the test gets increased power, which leads to more identified genes. For more information see also \cite{Hong}.

\part{Z-statistic - posterior mean differential expression}
%\addcontentsline{toc}{part}{Z-statistic - posterior mean differential expression}
\section*{Introduction}
%\addcontentsline{toc}{section}{Introduction}
The main idea of this method is that one can use data from one study to construct a prior distribution of differential expression and thus utilize the posterior mean differential expression, weighted by variances, whose distribution is standard normal distribution due to classic Bayesian probability calculation. \par
It is based on assumption that gene expression is normally distributed with mean $\mu_g $ and SD $\sigma^2_g$ and that we can estimate $\sigma^2_g$ by pooling together all genes with similar levels of mean intensity. The difference in gene expression is tested by
\[ Z=\frac{D}{\sigma_D}=\frac{\overline{X}_1 - \overline{X}_2}{\sqrt{\frac{\sigma_1^2}{n_1}+\frac{\sigma_2^2}{n_2}}} \sim N(0,1),\]
where $\overline{X}_1$ and $\overline{X}_2$ denotes mean gene expression values in classes, $\sigma_1^2$ and $\sigma_2^2$ denotes the estimated SD in classes and $n_1$ and $n_2$ denotes the number of samples in classes. 
\section*{Usage}
%\addcontentsline{toc}{section}{Usage}
\subsection*{Data preparation}
Because the same number of samples in each class and study is used in primary publication of the method \cite{Wang}, we will first look at number of samples in our data.
<<Zdata>>=
table(pData(denmark)[,1])
table(pData(australia)[,1])
table(pData(japan)[,2])
@
The smallest value in the tables above is 5, therefore we will randomly choose 5 samples in each class and data set. Function {\ttfamily dataZ} performs such data reduction. It has four required arguments: a data set as ExpressionSet object ({\ttfamily data}), number of column of \emph{pData} slot with class labels ({\ttfamily  group}), number of samples to be selected ({\ttfamily nsamp}) and name for class labels ({\ttfamily varname}). We need to merge the data sets into one {\ttfamily mergeExprSet} object created by function {\ttfamily mergeExprs} from R package {\itshape MergeMaid}. 
<<Zdata2>>=
denmarkZ<-dataZ(data=denmark, group=1, nsamp=5, varname="satelite")
australiaZ<-dataZ(australia,1,5,"satelite")
japanZ<-dataZ(japan,2,5,"satelite")
library(MergeMaid)
merged<-mergeExprs(denmarkZ,australiaZ,japanZ)
@ 
Now, we can proceed to detecting differentially expressed genes. 
\subsection*{Detecting differentially expressed genes}
We apply this method by
<<Zdeg>>=
z.stat<-Zscore(merged)
@ You can set additional parameter {\ttfamily permute} to generate permutation distribution to determine significance of the observed statistic. Using, for example {\ttfamily permute=1000} will generate permutation distribution of z-statistic by permuting class labels within all studies 1,000 times. 
\subsection*{Results}
<<>>=
head(round(z.stat,3))
@
Only values of Z-statistic ({\ttfamily Zscore}) and their p-values ({\ttfamily Pvalue}) are provided by function {\ttfamily Zscore}.
\section*{Notes and discussion}
%\addcontentsline{toc}{section}{Notes and discussion}
This implementation expects either same microarray platform or same scale of expression values (like after POE transformation \cite{metaArray}) in all data sets.

\part{TSP-clasiffier}
%\addcontentsline{toc}{part}{TSP-clasiffier}
\section*{Introduction}
%\addcontentsline{toc}{section}{Introduction}
This method has been originally described in \cite{Geman}. A top scoring pair (TSP) is a pair of genes whose relative ranks can be used to classify arrays according to a binary phenotype. A top scoring pair classifier has three advantages over standard classifiers:
\begin{enumerate}
\item the classifier is based on the relative ranks of genes and is more robust to normalization and preprocessing,
\item the classifier is based on a pair of genes and is likely to be more interpretable than a more complicated classifier, 
\item a classifier based on a small number of genes lends itself diagnostic tests based on PCR that are both more rapid and cheaper than classifiers based on a large number of genes.
\end{enumerate}
\section*{Usage}
%\addcontentsline{toc}{section}{Usage}
In this section we will demonstrate the use of the functions made for meta-analysis of example data sets. We will show how to calculate top scoring pair, how to calculate p-values for significance and how to plot TSP objects. 
\subsection*{Data preparation}
We are going to use function {\ttfamily mergedata} again. Please see Data preparation section of RankProduct part for details.  
<<TSPdata>>=
tspdata<-mergedata(denmark, australia, japan, class.col=c(1,1,2))
@
\subsection*{Detecting differentially expressed genes}
Function {\ttfamily tspcalc} calculates top scoring gene pair. It has two arguments: {\ttfamily dat} and {\ttfamily grp}. {\ttfamily dat} can be either an $m$ genes by $n$ samples matrix of expression data or an ExpressionSet object. There are also two posibilities for {\ttfamily grp}: A group indicator in character or numeric form or an integer indicating the column of \emph{pData()} to use as the group indicator. We use gene expression data matrix and vector of numeric class labels. 
<<TSPdeg>>=
tsp<-tspcalc(dat=tspdata$dat, grp=tspdata$cl)
@ 
We can compute the significance of a top scoring pair, too. It calculates "how strong a top scoring pair is". \par
The function {\ttfamily tspsig} performs a permutation test with the null hypothesis that no TSP exists in the data set. It permutes the group labels $B$ times and calculates a null TSP score for each time. The p-value is then the total number of null TSP scores that exceed the observed TSP score plus $1$ divided by $B + 1$. A progress bar indicates the time left in the calculation. You have to again specify the data expression matrix, class labels and additionally the number of permutations. You can also set the seed for permutations to make results reproducible. 
<<>>=
out<-tspsig(tspdata$dat,tspdata$cl,B=50)
@                                               
\subsection*{Results}
Function {\ttfamily tspcalc} returns a tsp object.
<<TSPres>>=
tsp
@
In the output above each row refers to one top scoring pair. \emph{TSP Score} is TSP score as defined in \cite{Geman}, essentially it is the empirical average of sensitivity and specificity for the pair. \emph{Tie-Breaker} denotes the tie-breaking score described in \cite{Tan}. Briefly, each expression value is ranked within its array, then a rank difference score is calculated for each pair of genes. Finally, \emph{Indices} gives the rows of the gene expression matrix that define a top scoring pair.
\begin{center}
<<fig=true, width=5, height=5>>=
tspplot(tsp)
@
\end{center}
 The {\ttfamily tspplot} accepts a tsp object and returns a TSP plot. The figure plots the expression for the first gene in the TSP pair versus the expression for the second gene in the TSP pair across arrays. The user defined groups are plotted in the colors red and blue. The score for the pair is shown across the top of each plot. If there is more than one TSP, hitting return will cycle from one TSP to the next.
<<>>=
summary(out)
out$p
out$nullscores
@
\emph{p} and \emph{nullscores} are two the most interesting elements of output from {\ttfamily tspsig} function. The former is the significance of TSP and the latter contains top scores observed in permutations.
%\section*{Discussion}
%\addcontentsline{toc}{section}{Discussion}
          
\part{VennMapping}
%\addcontentsline{toc}{part}{VennMapping}
\section*{Introduction}
%\addcontentsline{toc}{section}{Introduction}
VennMapping \cite{Smid} is a method based on Venn diagrams and contingency tables. It looks for number of common genes in pairs of gene lists, statistical significance of observed match and returns also names of the common genes.
\section*{Algorithm}
%\addcontentsline{toc}{section}{Algorithm}
Algorithm of this method consists of three steps:
\begin{enumerate}
\item Calculation of fold-change in each data set.
\item Selection of significant (interesting) genes.
\item Comparison of gene lists pairs.
\end{enumerate}

\section*{Usage}
%\addcontentsline{toc}{section}{Usage}
\subsection*{Data preparation}
Function {\ttfamily fold.change} calculates mean fold-change in one data set. It has two arguments: data set (e.g. {\ttfamily denmark}) and column number of \emph{pData} slot with class labels to be used. It assumes data are on $log_2$ scale.
<<VennFCH>>=
fc.d<-fold.change(denmark,1)
fc.a<-fold.change(australia,1)
fc.j<-fold.change(japan,2)
FC<-cbind(fc.d, fc.a, fc.j)
@
Function {\ttfamily gene.select} selects significant/interesting genes from mean fold-change matrix with rows referring  to genes and columns to data sets. The user has to specify (apart from mean fold-change matrix) a cutoff for selection. The cutoff is on $log_2$ scale, too. We chose $1$ for genes with at least 2-fold change in expression.
<<>>=   
list<-gene.select.FC(FC,1)
summary(list)
@
Object {\ttfamily list} is a list in which each slot contains names of selected genes in one study. For example from the print above 33 genes have been selected in {\ttfamily denmark} data set. 
\subsection*{Detecting differentially expressed genes}
Now, we can move on comparison of selected gene lists in pairs of data sets. There are three functions to perform such a analysis: {\ttfamily conting.tab}, {\ttfamily Z} and {\ttfamily gene.list}. {\ttfamily conting.tab} returns contingency table with number of common genes. {\ttfamily Z} provides Z statistic to measure significance of observed number of common genes and {\ttfamily gene.list} outputs table with names of common genes. All of them have one argument same - it is a list object with names of selected genes in individual data sets. For function {\ttfamily Z} one additional argument is necessary - the number of genes involved in meta-analysis (calculated by {\ttfamily length(rownames(exprs(denmark)))}). 
<<>>=
conting.tab(list)
Z(list, n=length(rownames(exprs(denmark))))
gene.list(list)
@
%\subsection*{Results}
%\section*{Discussion}
%\addcontentsline{toc}{section}{Discussion}

\part{MAP-Matches}
%\addcontentsline{toc}{part}{MAP-Matches}
\section*{Introduction}
%\addcontentsline{toc}{section}{Introduction}
Meta-Analysis Pattern Matches (MAP-Matches) \cite{Yang2005} is a method that extends VennMapping \cite{Smid} and meta-profiling \cite{velkyRhodes}. It is designed to analyze more distinct microarray data (search for common molecular mechanism in all types of cancer). It assumes same gene set in all data sets. 
\section*{Algorithm}
%\addcontentsline{toc}{section}{Algorithm}
Algorithm of this method has five steps:
\begin{enumerate}
\item Calculation of T-statistic for each two classes in each data set. 
\item Building matrix of T-statistics (T-matrix) with rows referring to genes and columns to pairs of classes and data set.
\item Selection of threshold for T-statistic.
\item Transformation of T-matrix into a binary matrix: 1 for T-statistics above threshold, 0 for T-statistics below threshold.
\item Statistical analysis of transformed T-matrix (more details in Usage section).  
\end{enumerate}

\section*{Usage}
%\addcontentsline{toc}{section}{Usage}
\subsection*{Data preparation}
The analysis starts with calculation of T-statistics. Function {\ttfamily meta.test} returns a list with two slots: matrix of test statistics ({\ttfamily test}) and matrix of p-values ({\ttfamily p}). In each of the matrices rows correspond to genes and columns to data sets. We need only {\ttfamily test} slot for this method. Argument {\ttfamily class.col} is a numeric vector indicating which column of \emph{pData} should be used and {\ttfamily data.names} is a character vector with names of the data sets. 
<<>>=
stat.real<-meta.test(denmark, australia,japan, class.col=c(1,1,2), data.names=c("denmark","australia","japan"))$test
colnames(stat.real)<-c("Denmark","Australia","Japan")
@
\subsection*{Detecting differentially expressed genes}
The do not select significant genes in each study we only set threshold for T-statistics. We decided for 98 \% quantile (same in \cite{Yang2005}). 
<<MAPTcutoff>>=
stat<-c(stat.real)
quan<-T.select(stat)
T.default <- quan["98.00%"]
@
Now, we transform {\ttfamily stat.real} (T-matrix) into a binary matrix. We replace T-statistics above threshold with $1$ and below with $0$.
<<>>=
value.dis <- apply(stat.real,MARGIN=c(1,2), function(x) ifelse(abs(x)>T.default,1,0))
rownames(value.dis)<-featureNames(denmark)
head(value.dis)
@
Each row {\ttfamily value.dis} is called a meta-analysis pattern. We are going to analyze their occurrence, significance and genes they occur at. Function {\ttfamily ratio} provides basic summarization of {\ttfamily value.dis}. 
<<ratio>>=
results<-ratio(value.dis)
summary(results)
@
In {\ttfamily results} we can find: number of genes with T-statistic sufficiently high in each study \emph{n}, patterns observed in data (\emph{X.String}), probability of observing strong match (\emph{p.strong}) and probability of observing soft match (\emph{p.soft}). We say two patterns match strongly if they are equal. The rule for soft match is weaker as only $1$'s in patterns must match. \par
Function {\ttfamily MAPmatrix} calculates a matrix with rows corresponding to patterns and four columns: unique patterns that are being observed in our data (\emph{uniqe.pat}), number of observed soft matches with the pattern (\emph{n.soft}), number of observed strong matches (\emph{n.strong} and number of $1$'s in the pattern \emph{n.sig}).
<<allpatterns>>=
MAPmat<-MAPmatrix(value.dis)
MAPmat
@
Only pattern with multiply $1$'s are connected with common molecular mechanism and we will focus on them in the rest of analysis.
<<selpaternX>>=
MAPmat2<-MAPmat[MAPmat$n.sig>1,]
unique.pat<-as.character(MAPmat2[,1])
@
We assume that sufficiently high number of strong matches may provides evidence of common molecular mechanism. Functions {\ttfamily MAPsig1} and {\ttfamily MAPsig2} perform statistical analysis to answer whether we observe significant number of matches or not. The statistical analysis can be done in two ways (both based on permutation testing): we either permute columns of T-matrix (in binary form) or permute class labels in data sets and repeat the whole procedure with same threshold for T-statistics. The former is implemented in {\ttfamily MAPsig1} and the latter in {\ttfamily MAPsig2}. Function {\ttfamily test.group.shuffle} calculates T-statistics with permuted class label repeatedly. 

<<MAPsig1>>=
p1<-MAPsig1(unique.pat,value.dis,iter=1000)
p1
@
<<MAPsig2,results=hide>>=
den.shuf<-test.group.shuffle(data=denmark, dataname="Denmark")
aus.shuf<-test.group.shuffle(data=australia, dataname="Australia")
jap.shuf<-test.group.shuffle(data=japan, dataname="Japan",var=2)
dataset <- c("Denmark","Australia","Japan")
p2<-MAPsig2(dataset, value.dis, unique.pat, B=100)
@
<<>>=
p2
@
Both \emph{p1} and \emph{p2} have same structure: rows refer to patterns and columns to statistical signifficance of observed soft (\emph{p.soft} or \emph{permu.soft}) or strong (\emph{p.strong} or \emph{permu.strong}) matches. 
\subsection*{Results}
Finally, we will bind all necessary outputs together. 
<<MAPres>>=
resx <- cbind(MAPmat2, p1, p2)
colnames(resx) <-c(colnames(MAPmat2), "p.strong", "p.weak", "p.permu.strong", "p.permu.weak")
intx <- t(as.matrix(resx[which(resx[,4]<0.06),]))
t(resx)
@ 
We can plot p-values by
\begin{center}
<<fig=true,width=4,height=4>>=
plotpattern(resx, method=1)
@ 
\end{center}
or
\begin{center}
<<fig=true,width=4,height=4>>=
plotpattern(resx, method=2)
@ 
\end{center}
Until now, we have only found out that for some patterns there is significantly high count of strong or soft matches being observed. Obviously we want to know expression of which genes is changed in these patterns. Function {\ttfamily MAP.genes} returns a list in which each slot contains list of genes involved in one pattern. If argument {\ttfamily files} is set to {\ttfamily TRUE} a files with gene names are also saved. 
<<>>=
probs<-MAP.genes(resx,value.dis, files=FALSE)
names(probs)<-rownames(resx)
summary(probs)
@
\emph{probs} is a list with each slot referring to one pattern and list of gene names is stored there. The pattern has been observed at these genes.  
\par
If there is annotation package available for microarray platform used in meta-analysis we can create a HTML annotation of found patterns by 
<<MAPanno>>=
library(annaffy)
library(hgu133plus2.db)
MAP.HTMLanno(resx, probs, "hgu133plus2.db")
@
%\section*{Discussion}
%\addcontentsline{toc}{section}{Discussion}

\part{METRADISC}
%\addcontentsline{toc}{part}{METRADISC}
\section*{Introduction}
%\addcontentsline{toc}{section}{Introduction}
METRADISC \cite{Zintzaraz} is unique among rank-based methods (like Rank Product or TSP) because it provides an estimate of heterogeneity as one of its outputs. Additionally the method can deal with genes which are being measured in only some of the studies. The implementation available in MAMA package is restricted to genes common in all microarray studies analyzed.
\section*{Algorithm}
%\addcontentsline{toc}{section}{Algorithm}
\begin{enumerate}
\item Gene Ranking - In microarray analysis we usually test samples for a large number of genes. The results provide for each gene a test statistic and its statistical significance (p-value). Therefore we can rank the tested genes in each study based on direction in expression change and statistical significance. If there are $n$ genes being tested, the highest rank $n$ is given to the gene that shows the lowest $p$-value and it is up-regulated in diseased samples. Then follow all other up-regulated genes ranked according to increasing $p$-value. These are followed by down-regulated genes and the lowest rank ($1$) is given to gene that shows the lowest $p$-value and is down-regulated in diseased samples. Genes with equal $p$-values are assigned tied ranks. 
\item The Average Rank and Heterogeneity metrics - In this step we compute a average rank and heterogeneity metrics. The average rank $R^*$ is defined as $R^*= \frac{\sum_{i=1}^{s}R_i}{s}$, where $R_i$ is the rank of the gene in study $i$ and $s$ is total number of studies ($i=1,2,...,s$). The heterogeneity metrics $Q^*$ is given by formula $Q^*=\sum_{i=1}^{s}(R_i-R^*)^2$, it is actually generalization of Cochran's $Q$ statistic. 
\item Monte Carlo permutation test - To obtain statistical significance for average rank and heterogeneity metrics we randomly permute the ranks of each study and the stimulated metrics are calculated. Then we repeat the procedure to generate null distribution for the metrics. Each variable is then tested against the corresponding null distribution. We are interested genuinely in four statistical significances: for high average rank, for low average rank, for high heterogeneity and for low heterogeneity. Distinction between high and low average rank is important as we want to keep the direction of effect in mind. Ignoring it can lead to spurious results that a gene is consistently significant even if it is up-regulated in one study and down-regulated in second one. On the other hand, statistically low heterogeneity may suggest consistent results among different studies. The statistical significance for high average rank ($R^*$) is defined as the percentage of simulated metrics that exceed or are equal to the observed ($R^*$). The statistical significance for low average rank ($R^*$) is defined as the percentage of simulated metrics that are below or equal to the observed ($R^*$). Significance of heterogeneity is defined analogously.  
\end{enumerate}
\section*{Usage}
%\addcontentsline{toc}{section}{Usage}
\subsection*{Data preparation}
We will start with computing test statistic and p-value for each gene and data set. Function {\ttfamily meta.test} returns a list with two slots: data frame of test statistics and data frame of p-values. In each of the matrices rows correspond to genes and columns to data sets. Argument {\ttfamily class.col} is a numeric vector indicating which column of \emph{pData} should be used and {\ttfamily data.names} is a character vector with names of the data sets. 
<<METRAdat>>=
metra<-meta.test(denmark, australia,japan, class.col=c(1,1,2), data.names=c("denmark","australia","japan"))
head(metra$test)
@
\subsection*{Detecting differentially expressed genes}
Now, we can proceed to ranking genes. Function {\ttfamily rank.genes.adv} ranks the genes as described in Algorithm section above. 
<<>>=
RANK<-rank.genes.adv(metra)
head(RANK)
@
The genes ranks can be visualized by
\begin{center}
<<fig=TRUE,height=5,width=5>>=
RANK2<-RANK[order(RANK[,1]),]
colnames(RANK2)<-c("Denmark","Australia", "Japan")
heatcol<-colorRampPalette(c("Green", "Black", "Red"))(100)
metaheat(as.matrix(RANK2), col=heatcol)
@ 
\end{center}
The next step is to compute average rank $R^*$ and heterogeneity metric $Q^*$ for each gene.
<<METRArq>>=
RQ<-compute.RQ(RANK)
head(round(RQ,1))
@
And finally we use function {\ttfamily MCtest} to perform Monte Carlo permutation test. Function requires the observed ranks ({\ttfamily RANK}), observed average rank and heterogeneity metric ({\ttfamily RQ}) and number of permutations ({\ttfamily nper}) as arguments. Number of permutations depends on the required accuracy for the final $p$-values. $1/nper$ is the accuracy for the final $p$-values. For example with $1000$ permutations the $p$-values are calculated with three decimal places.  
<<METRAmc>>=
MC<-MCtest(RANK,RQ, nper=1000)
head(MC)
@
\subsection*{Results}
The command below creates a character vector of genes with significant average ranks and low heterogeneity. The selected threshold for statistical significance is $0.01$.
<<>>=
METRA<-c(rownames(MC)[MC[,1]<0.01 & MC[,4]<0.01], rownames(MC)[MC[,2]<0.01 & MC[,4]<0.01])
METRA[1:10]
@
%\section*{Discussion}
%\addcontentsline{toc}{section}{Discussion}

\part{Results combination}
%\section{Methods comparison}
In this part we are going to compare and combine outputs from all methods so we can look and changes in gene expression in various ways. \par
We are going to start with lists of differentially expressed genes, because this is the only one output common for all methods mentioned in this vignette. We will merge all lists into one variable via function {\ttfamily join.DEG}. The function requires a complete list of genes involved in meta-analysis so it can map indices to gene names like for example function {\ttfamily pvalcombination} provides. Function {\ttfamily featureNames()} returns a character vector with genes present in the ExpressionSet object. Because the same set of genes was measured in each data set we can arbitrarily choose one data set. 
<<>>=
lists<-join.DEG(pvalt, ESt, ScoresFDR, x.z, RankRes, z.stat, tsp, probs,genenames=featureNames(denmark), type=c(1,1,3,4,5,6,7,8), cutoff=0.01)
names(lists)<-c("PvalCom", "ESCom","ESCom2","OrderedList","RankProduct", "Z-stat","TSP","MAP")
summary(lists)
@
Now, we will transform this list to a binary matrix where rows refer to genes and columns to method and $1$ means that the gene was identified as a differentially expressed gene in the method. Function {\ttfamily make.matrix} provides such transformation.  
<<>>=
MAT<-make.matrix(lists)
MAT[1:5,1:5]
@
It is very popular to visualize results of microarray analysis as a heatmap. A heatmap is a graphical representation for a numeric matrix where values are presented as colors. Gene expression values are usually used in microarray analysis. In these pictures colors go continuously from green (for down-regulation) through black (for no change in gene expression) to red (for up-regulation). There are several R-packages which implement plotting heatmaps in slightly different way. Functions {\ttfamily metaheat} and {\ttfamily metaheat2} are modification of two of them, so a discrete set of colors (only two in {\ttfamily metaheat} but even several in {\ttfamily metaheat2}) can be used with an appropriate legend.\par
Function {\ttfamily metaheat} has three arguments: a data matrix ({\ttfamily MAT}), a number defining position of legend ({\ttfamily legend=1} is legend drawn below the picture) and vector of colors ({\ttfamily col}). 
\begin{center}
<<fig=true, width=6, height=6>>=
metaheat(MAT, legend=1, col=c("khaki1", "lightsalmon3"))
@      
\end{center}                  
 Function {\ttfamily metaheat2} has as many arguments as {\ttfamily heatmap.2} form gplots package and two more. Argument {\ttfamily legend.names} is a character vector with labels to be used in legend. Setting {\ttfamily discret=TRUE} will indicate that legend for discrete values should be drawn. 
\begin{center}
<<fig=true, width=6, height=9>>=
metaheat2(MAT, col=c("khaki1", "lightsalmon3"), legend.names=c("DEG","noDEG"), discrete=TRUE, trace="none", dendrogram="none")
@       
\end{center}
The user can perform cluster analysis on {\ttfamily MAT} to search for similarities between methods or genes.\par
We can look at number of genes found by number of methods by
<<>>=
dim(MAT)
@
According to the outsprint above, eight different methods have found 217 differentially expressed genes. \par
The histogram below shows that the most of the genes have been selected in only one method. 
\begin{center}
<<fig=true, width=4, height=4>>=
n.met<-apply(MAT,1,sum)
hist(n.met, main="", xlab="Number of methods", ylab="Number of genes", xlim=c(1,8))
@
\end{center}
{\ttfamily n.met} is a numeric vector of number of methods that identified the gene as differentially expressed. \par 
Next, we can look for example how many genes have been found as differentially expressed in at least 6 methods.
<<>>=
dim(MAT[n.met>5,])
@
On the other hand, we can find out how many genes have been found by a method.
\begin{center}
<<fig=true, width=4, height=4>>=
n.gen<-apply(MAT,2,sum)
barplot(n.gen, cex.names=0.8, las=2)
@
\end{center}
Function {\ttfamily contig.tab} provides a number of genes common in two gene lists. It can be applied to {\ttfamily lists}, too.
<<>>=
TAB<-conting.tab(lists)
TAB[1:5,1:5]
@
%Integration Driven Discovery (IDD) and Integration Driven Revision (IDR) became popular for methods which combine p-values or effect sizes. IDD is a gene that has been found significant in meta-analysis but not in any of one data set analyses. A gene that is significant only in one data set analysis and not in meta-analysis is called IDR. A high number of IDD suggests that the method is capable to catch small but constant changes in gene expression, whereas high number of IDR is being explained as capability to suppress great expression changes observed in only one data set.\par % Function {\ttfamily makeIDDIDRtable()} provides IDD/IDR characteristic of all 

\section*{Expression of one gene}
In this section we are going to focus on one gene and to look at its expression change from different points of view. The different points of view are represented by different approaches used in the methods.\par
First we will join all the available results to one list and then select only rows for one gene.\par

<<>>=
results<-join.results(pvalt, ESt, theScores, ScoresFDR$two.sided, x.z, RankRes, z.stat, probs, MC, RQ, type=c(1,1,5,5,2,3,5,4,5,5), genenames=rownames(exprs(denmark)))
gene<-metagene("203008_x_at",results)
gene
save(gene,file="gen.RData")
@
This output provides much of the information available on the gene through all the described methods. It is a rather complicated structure, so we will try to represent it graphically in comprehensible form.
\begin{center}
<<fig=true, width=7,height=7>>=
plotgene(gene, type=c(1,1,2,3,4,5,6,7,8,9), datalabels=c("denmark", "australia", "japan", "combined"))
@
\end{center}
@
The picture above shows in top part occurrence of gene in ... , in list of overlapping genes in SOGL method and in gene lists with observed MAP (Meta-Analysis Pattern).  The dark box means that the gene is present in the list. Values from objects: {\ttfamily pvalt}, {\ttfamily ESt}, {\ttfamily x.z} and {\ttfamily probs} are used in here. \par
The middle part is dedicated to p-values available in meta-analysis. Specific values of the statistics can be found on the right side of the chart. The vertical dashed line denotes the signifficance threshold $5\%$. P-values from {\ttfamily MC}, {\ttfamily RankRes} and {\ttfamily z.stat} are drawn in here.\par
Combination of effect size is plotted in the bottom graph. The point marks the effect size. Horizontal lines denote the variance of effect size. Statistical significance of the difference in gene expression (FDR adjusted) can be found on the right side of the chart. This graph uses values from {\ttfamily theScores} and {\ttfamily ScoresFDR}.

\begin{thebibliography}{99}
\bibitem{ausaden}Jorissen, R. N., Lipton, L., Gibbs, P., Chapman, M. et al. 2008, \emph{DNA copy-number alterations underlie gene expression differences between microsatellite stable and unstable colorectal cancers}, Clinical Cancer Research, Vol. 14, pp. 8061-8069
\bibitem{japan}Watanabe, T., Kobunai, T., Toda, E., Yamamoto, Y. et al. 2006, \emph{Distal colorectal cancers with microsatellite instability (MSI) display distinct gene expression profiles that are different from proximal MSI cancers} Cancer Research, Vol.66, no. 20, pp. 9804-9808
\bibitem{Biobase}Falcon, S., Morgan, M. and Gentleman, R. 2007, \emph{An introduction to Biocinductor's ExpressionSet class}, available at: http://www.bioconductor.org/packages/2.2/bioc/vignettes/Biobase/inst /doc/ExpressionSetIntroduction.pdf
\bibitem{Marot}Marot, G., Foulley, J.L., Mayer, C.D.,Jaffrzic, F. 2009, \emph{Moderated effect size and P-value combinations for microarray meta-analyses}, Bioinformatrics, Vol. 25 no. 20 2009, pp. 2692-2699
\bibitem{Rhodes}Rhodes, D.R., Barrette, T.R., Rubin, M. A., Ghosh, D. a Chinnaiyan, A. M. 2002, \emph{Meta-Analysis of Microarrays: Interstudy Validation of Gene Expression Profiles Reveals Pathway Dysregulation in Prostate Cancer}, CANCER RESEARCH 62, pp: 4427-4433
\bibitem{Fisher25}Fisher, R.A. 1925, \emph{Statistical methods for research}, Oliver and Boyd, Edinburgh
\bibitem{limma}Smyth, G. K. 2004, \emph{Linear models and empirical Bayes methods for assessing differential expression in microarray experiments}, Statistical Applications in Genetics and Molecular Biology 3, No. 1, Article 3
\bibitem{SMVar}Jaffrzic, F., Marot, G., Degrelle, S., Hue, I., Foulley, J.L. 2007, \emph{A structural mixed model for variances in differential gene expression studies}, Genetical Research, Vol. 89, pp. 19-25.
\bibitem{Choi2003}Choi, J.K., Yu, U., Kim, S. a Yoo, O.J. 2003, \emph{Combining multiple microarray studies and modeling interstudy variation}, Bioinformatics, Vol. 19, Suppl. 1 2003, pp. i84-i90
\bibitem{GeneMeta}Gentleman, R., Rauschhaupt, M., Huber, W., a Lusa L. 2008, \emph{Meta-analysis for Microarray Experiments}, dostupn na: http://www.bioconductor.org/packages/2.3/bioc/vignettes/GeneMeta /inst/doc/GeneMeta.pdf 
\bibitem{Hedges}Hedged, V. L. a Olkin, I. 1985, \emph{Statistical Methods for Metaanalysis}, Academic Press, Orlando
\bibitem{Cochran}Cochran, B.G. 1954, \emph{The combination of estimates from different experiments}, Biometrics, Vol. 10, pp. 101-129
\bibitem{DerSimonian}DerSimonian, R., a Laird, N. M. 1986, \emph{Meta-analysis in clinical trials}, Controlled Clinical Trials, Vol. 7, pp. 177-188
\bibitem{SOGL}Scheid, S., Lottaz, C., Yang, X. a Spang, R. 2006, \emph{Similarities of Ordered Gene Lists User's Guide to the Bioconductor Package OrderedList 1.11.3}, dostupn na: http://www.bioconductor.org/packages/2.5/bioc/vignettes/
OrderedList/inst/doc/tr\_2006\_01.pdf
\bibitem{Hong}Hong, F., Breitling, R., McEntee,C. W., Wittner, B. S., Nemhauser, J. L. a Chory, J. 2006, \emph{RankProd: a bioconductor package for detecting differentially expressed genes in meta-analysis}, Bioinformatics, Vol. 22, no. 22 2006, pp. 2825-2827
\bibitem{Wang}Wang, J., Coombes, K. R., Highsmith, W. E., Keating, M. J. a  Abruzzo, L. V. 2004, \emph{Differences in gene expression between B-cell chronic lymphocytic leukemia and normal B cells: a meta-analysis of three microarray studies}, Bioinformatics, Vol. 20, no. 17 2004, pp. 3166-3178
\bibitem{metaArray} Ghosh, D. a Choi, H. 2009, \emph{metaArray package for meta-analysis of microarray data}, dostupn na: http://bioconductor.org/packages/2.5/bioc/vignettes/metaArray/inst/ doc/metaArray.pdf
\bibitem{Geman}Geman, D., d'Avignon, Ch., Naiman, D. Q. a Winslow, R.L. 2004, \emph{Classifying Gene Expression Profiles from Pairwise mRNA Comparisons}, Statistical Applications in Genetics and Molecular Biology 2004, Vol. 3, Issue 1, Article 19
\bibitem{Tan} A.C. Tan, D.Q. Naiman, L. Xu, R.L. Winslow, D. Geman, \emph{Simple decision rules for classifying human cancers from gene expression profiles}, Bioinformatics, 21: 3896-3904, 2005.
\bibitem{Smid}Smid, M., Dorssers, L. C. J. a Jenster, G. 2003, \emph{Venn Mapping: clustering of heterologous microarray data based on the number of co-occurring differentially expressed genes}, Bioinformatics, Vol. 19, no. 16 2003, pp. 2065-2071
\bibitem{Yang2005}Yang, X., Bentink, S. a Spang, R. 2005, \emph{Detecting Common Gene Expression Patterns in Multiple Cancer Outcome Entities}, Biomedical Microdevices, Vol.7:3, pp. 247-251
\bibitem{velkyRhodes}Rhodes, D. R., Yu, J., Shanker, K., Deshpande, N., Varambally, R., Ghosh, D., Barrette, T., Pandey, A. a Chinnaiyan, A. M. 2004, \emph{Large-scale meta-analysis of cancer microarray data identifies common transcriptional profiles of neoplastic transformation and progression}, PNAS, Vol. 101, no. 25, pp. 9309-9314
\bibitem{Zintzaraz}Zintzaraz, E a Ioannidis, J.P.A. 2008, \emph{Meta-analysis for ranked discovery datasets: Theoretical framework and empirical demonstration for microarrays}, Computational Biology and Chemistry 32, pp. 39-47
%\bibitem{Heatplus}
%\bibitem{gplots}
\end{thebibliography}
\end{document}

